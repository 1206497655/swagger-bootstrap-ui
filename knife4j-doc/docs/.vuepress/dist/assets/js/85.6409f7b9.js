(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{509:function(t,s,e){"use strict";e.r(s);var a=e(42),_=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_3-9-动态请求参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-9-动态请求参数"}},[t._v("#")]),t._v(" 3.9 动态请求参数")]),t._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),e("p",[e("code",[t._v("knife4j")]),t._v(" 版本>2.0.1 使用此规则")])]),t._v(" "),e("p",[t._v("在某些特定的情况下,因为我们对于接口使用的是一种先定义,后展示的规范执行,所以我们在界面上看到的请求参数,全部来源于我们后端接口层如何定义")]),t._v(" "),e("p",[t._v("但是如果后端定义的是一种Map结构,或者是参数并没有定义声明,而希望也能达到一种动态添加参数进行调试的结果,这种体验有点类似于"),e("code",[t._v("postman")])]),t._v(" "),e("p",[e("code",[t._v("Knife4j")]),t._v("针对上面的需求提供了支持")]),t._v(" "),e("p",[t._v("在"),e("code",[t._v("Knife4j")]),t._v("的前端页面中,个性化设置功能里,可以开启对参数的动态调试("),e("code",[t._v("该选项默认是关闭状态")]),t._v(")，如下图：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/knife4j/images/knife4j/plus/debugDynamic.png",alt:""}})]),t._v(" "),e("p",[t._v("当在配置中勾选该选项后,我们的接口栏会有变化,如下图：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/knife4j/images/knife4j/plus/debugDynamic1.png",alt:""}})]),t._v(" "),e("p",[t._v("在原本已存在的参数栏下会出现一栏空的参数栏,开发者可以输入参数名称、参数值对参数进行添加")]),t._v(" "),e("p",[t._v("不管是参数名称的变化还是参数值的变化,变化后会自动追加一行新的调试栏参数,效果图如下：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/images/knife4j/plus/dynamicparam3.gif",alt:""}})])])}),[],!1,null,null,null);s.default=_.exports}}]);